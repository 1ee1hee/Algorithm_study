########### My Solution(1-1) ###########

def solution(n):
    return sum([i for i in range(1, n+1) if n % i == 0])

print(solution(12)) #28
print(solution(5)) #6

"""
- 1부터 n까지 한 번씩 다 나눠봐서 나눠떨어지면(=나머지가 0이면) 약수로 판정하여 리스트에 추가
- 리스트에 저장된 모든 값을 sum으로 더해서 리턴

리스트 컴프리헨션 버전을 for문으로 풀어서 쓰면 아래와 같다.
"""
########################################

########### My Solution(1-2) ###########
def solution(n):
    nums = [] #빈 리스트
    for i in range(1, n+1):
        if n % i == 0: #i로 나눠떨어지면
            nums.append(i) #약수로 판정
    return sum(nums) #약수들을 모두 더해서 리턴

print(solution(12)) #28
print(solution(5)) #6

"""
하지만 이상의 방법은 총 n번의 연산을 필요로 한다.
n이 0 이상 3000 이하로 주어졌기 때문에 지금은 큰 문제가 없지만,
n에 엄청나게 큰 수가 들어온다면 연산 횟수를 줄여야 할 필요가 있다.
따라서 연산 횟수를 루트n번으로 줄일 수 있는 방법을 만들어 보았다.
"""
########################################

############ My Solution(2) ############
def solution(n):
    nums = set() #list가 아닌 set으로 만듦 (중복되는 값 거르기 위해)
    end_idx = int(n**(1/2)) #복잡해 보이지만 루트n이라는 뜻
    for i in range(1, end_idx+1): #원래 n의 자리에 루트n 넣음 (연산 횟수 줄이기 위해)
        if n % i == 0: #i로 나눠떨어지면
            nums.add(i) #약수로 판정
            nums.add(n // i) #짝꿍인 숫자도 같이 약수로 판정
    return sum(nums)

print(solution(12)) #28
print(solution(5)) #6

"""
약수와 그 짝꿍 약수를 한 번에 구하는 방법이다.

예를 들어, 36의 약수를 구하는 상황을 고려해 보자.

     1    2    3    4    6
    36   18   12    9
    
i=1일 때 1과 36을, i=2일 때 2와 18을, i=3일 때 3과 12를, ... 한 번에 찾아내는 방식이다.
이렇게 하면 총 36번 나눴던 기존의 방법과는 달리,
단 6번의 나눗셈만으로 모든 약수를 구할 수 있다.

이때 6의 짝꿍 수는 6이다. 이 경우 중복되는 값(=6)이 2번 들어갈 수도 있다.
그러므로 nums를 list가 아닌 set으로 만들어서 중복되는 값은 한 번만 들어가도록 만든다.
"""
########################################
